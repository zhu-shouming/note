#### Docker的由来

1. 环境配置问题，用户计算机环境不相同，如何确保软件能正常在不同计算机上运行
2. 虚拟机就是一种带环境安装的一种解决方案，但它资源占用多、冗余步骤多、启动慢
3. Linux容器是linux发展出的一种虚拟化技术，不是模拟一个完整的操作系统，而是对进程进行隔离，它启动块、资源占用少、体积小

#### Docker简介

- 属于linux容器的一种封装，提供简单易用的容器使用接口。Docker将应用程序与该程序的依赖打包在一个文件里，运行这个文件，就会生成一个虚拟容器。
- 用途
  - 提供一次性的环境
  - 提供弹性的云服务
  - 组件微服务架构
- 设置docker源
  1.  /etc/docker/下创建一个daemon.josn文件 
  2.  仓库地址保存在该文件中 

#### docker基本操作

```bash
$ docker --version # 查看docker的版本
# 如果提示docker没有权限，加上权限
$ sudo usermod -aG docker $USER
$ docker --help # docker帮助文档
```

##### docker image

> 应用程序及其依赖打包在image文件里面，简单理解为安装包

- 列出镜像

  ```bash
  $ docker images	# 列出本机的所有image文件
  $ docker images -q	# 仅列出镜像ID
  $ docker inspect jenkins # 列出镜像详细信息
  ```

- 下载镜像

  ```bash
  $ docker pull niginx # 下载niginx镜像
  ```

- 删除镜像

  ```bash
  $ docker rmi [imageName/ImageID] # 删除镜像
  ```

##### docker container

> image文件生成的容器实例，本身也是一个文件，称为容器文件。可以理解为提供的服务

- 列出容器

  ```bash
  $ docker contain ls # 查看运行的容器，等价于docker ps
  # 选项-a：表示列出所有的容器
  $ docker history ContainName # 查看容器运行的历史记录
  $ docker top ContainName # 查看容器的进程信息
  $ docker status ContainName # 查看容器的资源信息
  ```

- 运行容器

  ```bash
  $ docker run imageName/ImageID # 运行image文件，会生成一个正在运行的容器实例
  # 选项：
  #	--name：指定生成的容器名称
  #	-d：指定在后台生成日志
  #	-p：指定宿主机端口映射到容器服务端口
  #	-P：随机生成端口隐身到主机
  #	-i：与容器交互
  #	-t：指定终端，如bash
  #	--rm：创建容器，如果容器为exit状态，会自动删除创建的容器
  #	--net:指定要加入的网络
  #   -v:将本地文件和容器文件进行映射
  $ docker run -p 8000:3000 -it docker-test:0.0.1 /bin/bash
  $ docker exec ContainName # 进入容器
  ```

- 停止/开启容器

  ```bash
  $ docker stop ContainName # 停止容器
  $ docker restart ContainName # 开启容器
  ```

- 暂停/启动容器

  ```bash
  $ docker pause ContainName # 暂停容器状态
  $ docker unpause ContainName # 将暂停的容器启动
  ```

- 删除容器

  ```bash
  docker rm ContainName # 删除一个未运行的容器
  docker rm -f ContainName # 删除一个正在运行的容器
  ```

##### 共享images

#### network

> 默认容器与宿主机之间沟通的桥梁

##### 网络类型

- briage
  - nat网络模型
  - 虚拟交换机
- host
  - 与宿主机共享网络，--net=host
- none
  - 不配置网络，--net=none
- overlay
  - 不同网络进行通信，--net=container:ContainerName

##### 网络基本操作

```bash
$ docker network ls	# 查看当前网络
$ docker network inspect NetworkName # 查看网络详情
$ docker network create mynetwork # 创建一个mynetwork的网络，默认为桥接模式
# 选项：
#	-d：指定网络类型，如：-d briage
#	--subnet:指定子网，如：--subnet 172.16.88.0/24
$ docker network -d briage --subnet 172.16.88.0/24 mynetworktest
$ $ docker run --name nginx -d -P --net mynetworktest nignx:alpine	# 创建名为nginx的容器并加入mynetworktest网络
```

#### volume

##### 介绍

- 使用数据卷实现数据持久化
- 数据备份/数据共享

##### 相关操作

```bash
$ docker volume create [OPTIONS] [VOLUME] # 创建
$ docker volume inspect [OPTIONS] VOLUME [VOLUME...] # 查看
$ docker run -v 宿主机目录:容器目录
$ docker volume rm [OPTIONS] VOLUME [VOLUME...] # 删除
```







#### 容器文件









#### Dockerfile文件

- Dockerfile是一个文本文件，用来配置image。Docker根据Dockerfile生成二进制的image文件

##### 制作自己的Docker容器

1. 编写Dockerfile文件

   - 忽略打包进入image文件

     ```shell
     # 新建文本文件.dockerignore，在文件里填写需要忽略的文件
     ```

   - 项目跟目录下，新建文件文件Dockerfile，内容如下：

     ```shell
     FROM node:8.4	# image文件继承官方的node image，冒号表示标签，这里标签是8.4，即8.4版本的node
     COPY . /app	# 将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入image文件的/app目录
     WORKDIR /app	# 指定接下来的工作路径为/app
     RUN npm install --registry=https://registry.npm.taobao.org	# 在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入image文件
     EXPOSE 3000	# 将容器3000端口暴露出来
     ```

2. 创建image文件

   ```bash
   # docker image build命令创建image文件
   # 	-t参数用来指定 image 文件的名字
   #	后面还可以用冒号指定标签。如果不指定，默认的标签就是latest
   #	最后的那个点表示 Dockerfile 文件所在的路径
   $ docker image build -t docker-test:0.0.1 .
   # 如果运行成功，就会看到新生成的docker-test
   $ docker image ls
   ```

3. 生成容器

   ```bash
   # -p：容器的3000端口映射到本机的8000端口
   # -it：容器的Shell映射到当前的Shell
   # docker-test:0.0.1:image文件的名字（如果有标签，还需要提供标签）
   # /bin/bash：容器启动以后，内部第一个执行的命令。保证用户可以使用shell
   $ docker container run -p 8000:3000 -it docker-test:0.0.1 /bin/bash
   ```

4. 启动服务

   ```bash
   # 创建好容器后可以进入容器手动运行项目
   # 	也可以将运行命名卸载Dockerfile中，容器启动命令自动执行（CMD命令）
   #	指定CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令
   CMD node demos/01.js	# 表示容器运行后自动执行node demos/01.js
   ```

#### 常用命令

```bash
$ docker container start [containerID]	# 启动已经生成、已经停止运行的容器文件
$ docker container stop [containerID]	# 终止容器运行
$ docker container logs [containerID]	# 查看docker容器的输出
$ docker container exec -it [containerID] /bin/bash	# 进入一个正在运行的 docker 容器
$ docker container cp [containID]:[/path/to/file] # 从正在运行的 Docker 容器里面，将文件拷贝到本机
```



