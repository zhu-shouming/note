#### 容器生态系统

1. 容器核心技术：容器在单个host上运行起来的那些技术
   1. 容器规范：runtime spec和image format spec
   2. 容器runtime：runtime需要和操作系统kernel紧密协作，为容器提供运行环境。lxc、runc和rkt是目前主流的三种容器runtime
   3. 容器管理工具：lxd是lxc对应管理工具；runc管理工具是docker engine，docker engine包含后台deamon和cli两个部分；rkt的管理工具是rkt cli
   4. 容器定义工具：允许用户定义容器的内容和属性，docker image是Docker容器的模板；dockerfile包含若干命令的文本文件，可通过这些命令创建docker iamge；ACI与docker image类似，由CoreOS开发的rkt容器的image格式。
   5. Registries：Docker Registry构建私有的Registry；Docker Hub是docker为公众提供的托管Registry；Quay.io与Docker Hub类似。
   6. 容器OS：专门运行容器的操作系统。如coreos、atomic、ubuntu core
2. 容器平台技术：让容器作为集群在分布式环境中运行
   1. 容器编排引擎：基于容器的应用一般会采用微服务架构，基于微服务的应用实际上是一个动态可伸缩的系统，而容器编排引擎是一种高效的方法来管理容器集群
      - docker swarm是docker开发的容器编排引擎
      - kubernetes是Google领导开大的开源容器编排引擎，同时支持Docker和CoreOS容器
      - mesos是一个通用的集群资源调度平台，mesos与marathon一起提供容器编排引擎
   2. 容器管理平台：架构在容器编排引擎之上的一个更为通用的平台，抽象了编排引擎的底层实现细节，为用户提供更方便的功能。Rancher和ContainerShip是容器管理平台的典型代表
   3. 基于容器的PaaS：为微服务应用开发人员和公司提供了开发、部署和管理应用的平台，使用户不必关心底层基础设施而专注于应用的开发。Deis、Flynn和Dokku都是开源容器PaaS的代表
3. 容器支持技术
   1. 容器网络：docker network是Docker原生的网络解决方案，还可以采用如flannel、weave和calico
   2. 服务发现：保存容器集群中所有微服务最新的信息，并对外提供API，提供服务查询功能。etcd、consul和zookeeper是服务发现的典型解决方案
   3. 监控：docker ps/top/stats是Docker原生的命令行监控工具。sysdig、cAdvisor/Heapster和Weave Scope是其他开源的容器监控方案
   4. 数据管理：Rex-Ray管理工具
   5. 日志管理：docker logs和logspout
   6. 安全性：OpenSCAP是一种容器安全工具

#### Docker架构

Docker的核心组件包括：

- Docker客户端：Client

- Docker服务器：Docker Daemon

  - 配置允许任意IP的客户端连接

    ```bash
    编辑配置文件/etc/systemd/system/multi-user.target.wants/docker.service，/etc/systemd/system/multi-user.target.wants/docker.service
    ```

  - 重启Docker daemon

    ```bash
    systemctl daemon-reload
    systemctl restart docker
    ```

- Docker镜像：Image

- Docker镜像仓库：Registry

- Docker容器：Container

#### Docker镜像

##### 镜像的分层结构

最大的好处是共享资源，容器的修改会被限制在单个容器内，镜像内容不会被修改

##### 构建镜像

docker提供了两种构建镜像的方法：docker commit命令和Dockerfile构建文件

###### docker commit

1.运行容器;2.安装;3.保存为新镜像

###### Dockerfile构建文件

1. 准备Dockerfile文件

2. docker build -t 镜像名:tag -f dockerfile文件路径

   注：build context为当前执行构建所在目录，该目录下的所有文件和子目录都会被发送给Docker daemon。不要将多余文件放到build context，特别不要把 /、/usr作为build context，否则构建过程会相当缓慢甚至失败。

###### Dockerfile文件命令详解

- FROM xxx：将xxx作为base镜像

- MAINTAINER:设置镜像的作者，可以是任意字符串

- COPY 文件 指定目录：将文件从build context复制到镜像

- ADD 文件 指定目录：从build context复制文件到镜像，同的是，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解压到dest

- ENV：设置环境变量，环境变量可被后面的指令使用

- EXPOSE：指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来

- VOLUME：将文件或目录声明为volume

- WORKDIR：为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录

- RUN：在容器中运行指定的命令

- CMD：容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被docker run之后的参数替换

- ENTRYPOINT：设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。

  ```bash
  FROM scratch	# scratch为一个虚拟镜像，表示从0开始
  COPY hello /	# 将文件复制到镜像的根目录
  ADD centos-xx.tar.xz /	# 将远端资源下载或本地文件复制到容器中
  CMD ["/hello"]	# 启动容器时执行hello文件
  ```

###### RUN vs CMD vs ENTRYPOINT

RUN：执行命令并创建新的镜像层，RUN经常用于安装软件包

CMD：设置容器启动后默认执行的命令及其参数，但CMD能够被docker run后面跟的命令行参数替换。

CMD：设置容器启动后默认执行的命令及其参数，但CMD能够被docker run后面跟的命令行参数替换。

运行命令格式：

- shell格式：`<instruction> <command>`，当指令执行时，shell格式底层会调用 /bin/sh -c [command]

- Exec格式:``<instruction> ["executable", "param1", "param2",...]`，当指令执行时，会直接调用 [command]，不会被shell解析

  注：CMD和ENTRYPOINT推荐使用Exec格式，因为指令可读性更强，更容易理解。RUN则两种格式都可以

##### 分发镜像

如何在多个Docker Host使用镜像

1. 用相同的Dockerfile在其他host构建镜像。
2. 将镜像上传到公共Registry（比如Docker Hub）, Host直接下载使用。
3. 搭建私有的Registry供本地Host使用。

搭建私有registry：https://docs.docker.com/registry/configuration/

##### 镜像操作常用命令

```bash
docker images	# 显示镜像列表
docker history 镜像ID	# 显示镜像构建历史
docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]	# 从容器创建新镜像
docker build -t 镜像名:tag -f dockerfile文件路径	# 从Dockerfile构建镜像
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]	# 给镜像打tag
docker pull [选项] [Docker镜像地址[:端口号]/] 仓库名[:标签]	# 从registry下载镜像
docker push	[选项] [Docker镜像地址[:端口号]/] 仓库名[:标签]	# 将镜像上传到registry
docker image rm [选项] <镜像1> [<镜像2> ...]	# 删除Docker host中的镜像
docker search 镜像名称:tag	# 搜索Docker Hub中的镜像
docker save -o mycontainer.tar mycontainer:latest	# 导出为压缩文件
docker load -i mycontainer.tar	# 导入压缩文件
```

#### Docker容器

##### 容器底层技术

- cgroup全称Control Group。Linux操作系统通过cgroup可以设置进程使用CPU、内存和IO资源的限额。在 /sys/fs/cgroup/cpu/docker、/sys/fs/cgroup/memory/docker和 /sys/fs/cgroup/blkio/docker中分别保存的是cpu相关、内存以及Block IO的cgroup配置
- namespace实现了容器间资源的隔离，Linux使用了6种namespace，分别对应6种资源：Mount、UTS、IPC、PID、Network和User

##### 运行容器

1. CMD执行令

2. ENTRYPOINT指令

3. 在docker run命令行中指定：docker run [options] image [command] [arg...] 

   ```bash
   # options详解
   -d	# 以后台方式启动容器
   --name xxx	# 显式地为容器命名
   -it	# 以交互模式打开终端，一般配合docker exec使用
   -p	# 指定宿主机端口映射到容器服务端口
   --restart=always	# 容器能够自动重启
   -restart=on-failure:3	#启动进程退出代码非0，则重启容器，最多重启3次
   --rm	# 如果容器为exit状态，会自动删除创建的容器
   --net	# 指定要加入的网络
   -v	# 将本地文件和容器文件进行映射
   -m	# 设置内存的使用限额，只指定 -m而不指定--memory-swap，那么--memory-swap默认为-m的两倍
   --memory-swap	# 设置内存+swap的使用限额
   --vm 1	# 启动1个内存工作线程
   --vm-bytes 280M	# 每个线程分配280MB内存
   -c或 --cpu-shares	# 设置容器使用CPU的权重。如果不指定，默认值为1024。
   ```

##### 容器操作常用命令

```bash
docker ps	# 查看Docker host中当前运行的容器，-a选项会显示所有状态的容器
docker logs -f 容器ID	# 查看容器运行日志，-f表示实时查看
docker kill/stop/start/restart 容器ID	# 快速停止/停止/启动/重启容器
docker pause/unpause 容器ID	# 暂停/恢复运行容器
docker create/rm 容器ID	# 创建/删除容器
docker history 容器ID # 查看容器运行的历史记录
docker inspect 容器ID	# 查看容器的配置和状态信息
docker cp xx.html ContainID://user/share/nginx/xx.html	# 拷贝本机xx.html到容器下
docker top ContainID # 查看容器的进程信息
docker stats ContainID # 查看容器的资源信息
```

#### Docker网络



#### 一、docker下载、安装及配置

##### 设置docker源地址

1. upstart的系统

   - 编辑 /etc/default/docker ，在 DOCKER_OPTS 中配置
   - 重启服务：sudo service docker restart

2. systemd的系统： /etc/docker/daemon.json 中写入如下内容（若没有文件则新建）

   ```json
   {   
     "registry-mirrors": [
       "https://xxxxxxxx.mirror.aliyuncs.com"
     ]
   }
   ```

   - 重新启动服务

     ```bash
     sudo systemctl daemon-reload
     sudo systemctl restart docker
     ```

**注**：1.需保持该文件符合json规范，否则docker将不能启动；2.检查加速地址是否生效：docker info

##### docker安装

- mac
  1. 浏览器下载安装包（www.docker.com）
  2. 安装，点击运行，`docker info`检测是否运行
  3. 可以配置docker源地址
- linux
  1. sudo wget -qO- httpd://get.docker.com | sh # 将wget下载简化输出到标准输出，将命令传递给sh执行。
  2. sudo usermod -aG docker $USER # 将用户添加到docker用户组
  3. docker info
```bash
$ docker --version # 查看docker的版本
$ docker --help # docker帮助文档
```

#### 五、dockerfile

- Dockerfile是一个文本文件，用来配置image。Docker根据Dockerfile生成二进制的image文件

##### 1.第一个Dockerfile

  ```dockerfile
  FROM alpine:latest
  MAINTAINER zsm
  CMD echo 'hello docker'
  ```
  FROM alpine:latest 表示要生成一个镜像，需要的一个base基础镜像，alpine是针对于linux生成的一个极小的文件
  MAINTAINER zsm  提示信息
  CMD echo 'hello docker' 表示运行的命令

##### 2.创建自定义image

1. 创建一个fun.py文件生成字符串团

   ```python
   from cowpy import cow
   
   print(cow.milk_random_cow("Hello world"))
   ```

2. 创建一个requirements.txt指定库的信息

   > cowpy==1.1.0

3. 项目根目录下编写Dockerfile文件，touch Dockerfile

   ```dockerfile
   # 指定基础镜像，FROM 基础镜像:标签版本标号
   FROM python:alpine
   LABEL maintaier="zsm <zsm@qq.com>" # 镜像的元数据信息，仅做描述。可以写多个LABEL
   LABEL description="define Dockerfile Demo"
   # ADD可以将远程资源下载后复制到容器，也可以将本地压缩文件解压后复制到容器中
   # COPY将requirements.txt、fun.py拷贝到image文件/app目录
   COPY . /app 
   # 指定接下来的工作路径为/app
   WORKDIR /app 
   # RUN用于容器中执行linux命令，如果有多条命令，优化选择使用一个RUN去执行多条命令，取代多个RUN执行单个命令
   RUN pip install -r requirements.txt
   # ENV key=value 指定环境变量
   # VoLUME指定容器哪个目录或文件可以映射
   VoLUME /app/
   # EXPOSE指定容器可以暴露的端口
   EXPOSE 8000
   # USER root:设置运行其他命令的用户
   # CMD指定容器运行（docker run）时默认执行的命令
   #	有两种格式：1.shell格式；2.exec格式（常用）
   #		exec格式：["命令的绝对路径", "参数1", "参数2"]
   #		shell格式：命令的绝对路径 参数1 参数2
   CMD ["python", "fun.py"]
   ```

   ps：新建文本文件.dockerignore，在文件里填写需要忽略的文件

4. 构建image文件

   ```bash
   # -t：指定镜像的名字,v1表示版本标签，.表示Dockerfile所在路径，docker build -t 镜像名:tag -f dockerfile文件路径
   $ docker build -t MyImage:v1 .
   ```
   
   备：可以在Dockerfile文件FROM之上定义ARG，在构建镜像中指定参数
   
   ```dockerfile
   ARG CODE_VERSION=alpine
   FROM python:${CODE_VERSION}
   ```
   
   ```bash
   $ docker build --build-arg CODE_VERSION=3.7-alpine -t 镜像名:tag
   ```

#### 六、network

##### 1.docker0

- 默认容器与宿主机之间沟通的桥梁

##### 2.网络类型

- briage：==自定义briage模型，可以通过容器名互反==
  - nat网络模型
  - 虚拟交换机
- host
  - 与宿主机共享网络，--net=host
- none
  - 不配置网络，--net=none
- overlay
  - 不同网络进行通信，--net=container:ContainerName

##### 3.网络基本操作

```bash
$ docker network ls	# 查看当前网络
$ docker network inspect NetworkName # 查看网络详情
$ docker network create mynetwork # 创建一个mynetwork的网络，默认为桥接模式
# 选项：
#	-d：指定网络类型，如：-d briage
#	--subnet:指定子网，如：--subnet 172.16.88.0/24
$ docker network -d briage --subnet 172.16.88.0/24 mynetworktest
$ docker run --name nginx -d -P --net mynetworktest nignx:alpine	# 创建名为nginx的容器并加入mynetworktest网络
```

#### 七、volume

##### 1.介绍

- 使用数据卷实现数据持久化
- 数据备份/数据共享

##### 2.相关操作

```bash
# 创建
$ docker volume create [OPTIONS] [VOLUME] 
# 查看
$ docker volume inspect [OPTIONS] VOLUME [VOLUME...] 
# 挂载
$ docker run -v 宿主机目录:容器目录
# 删除
$ docker volume rm [OPTIONS] VOLUME [VOLUME...] 

# 启动一个容器命名为nginx，随机分配端口，并将当前目录和容器/user/share/nginx/html作映射（双向同步）
$ docker run --name nginx -d -v $PWD:/user/share/nginx/html -P nginx:alpine
# 在映射文件后面加ro，表示宿主机只有读的权限
$ docker run --name nginx -d -v $PWD:/user/share/nginx/html:ro -P nginx:alpine
# 实际中，常用数据卷和容器文件进行映射,如果宿主机有myvolume数据卷直接进行映射，若是没有，创建myvolume并映射
$ docker run --name nginx -d -v myvolume:/user/share/nginx/html:ro -P nginx:alpine
```



#### 八、docker compose

作用：同时启动多个容器

##### 1.安装

##### 2.使用docker compose

- 项目根目录下创建docker-compose.yaml

  ```shell
  # 指定版本信息
  VERSION: '3'
  
  # 定义服务
  services:
  	# 创建的具体服务
  	db:
  		# 指定镜像名（镜像名:tag），如果本地没有，会从docker hub中下载
  		image:mariadb
		# 运行容器时，指定需要执行的命令或参数
  		command:--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
  		# 指定数据持久化映射
  		volumes:
  			# 数据卷名称或宿主机文件
  			mysql_db:/var/bin/mysql
  		# 指定容器失败时（EXITED），重启策略
  		restart:always
  		# 指定容器中的全局变量
          environment:
          	MYSQL_ROOT_PASSWORD:"123456"
          	MYSQL_DATABASE:my_django
          # 指定容器加入的网络
          networks:
          	django_app_net
      
      django_app:
      	# 指定django_app依赖的服务
      	depends_on:
      		db
      	# 指定通过Dockerfile路径（./django_app_docker）去构建（django_app:v1）镜像
      	build:./django_app_docker
      	image:django_app:v1
      	restart:always
          volumes:
          	logs:/usr/src/app/logs/
          	django_code:/usr/src/app/
          networks:
          	django_app_net
          	
  # 指定网络
  networks:
  	# 指定网络名称，默认会创建briage桥接网络
  	django_app_net
  	
  # 指定数据卷
  volumes:
  	mysql_db:
      django_code:    	
  	logs:		
  ```
  
  ##### 3.常用命令
  
  ```bash
  # 查看docker-compose.yaml文件配置是否有误
  $ docker-compose config
  # 如果执行命令目录下compose文件未命名docker-compose，需要使用-f指定文件
  $ docker-compose -f docker-pose.yaml config
  # 通过docker-compose文件启动容器，会在卷、网络、容器前面加前缀（当前所在目录名），可以使用-p指定前缀。一旦指定了，在删除容器的时候也需要使用-p指定相应前缀删除
  docker-compose -p my_project up	# 运行容器
  docker-compose -p my_project down # 删除容器、网络...
  ```

#### 九、Docker Swarm

##### 1.Swarm manager

- 切换、加入、移除、维护节点

##### 2.Swarm work

- 运行任务的节点
- 托管容器任务

##### 3.创建集群

- 初始化

##### 4.常用命令

```bash
# docker swarm去操作集群
$ docker swarm --help 
# docker node去操作节点
$ docker node --help
# docker service去操作服务
$ docker service --help
$ docker service ls
```
