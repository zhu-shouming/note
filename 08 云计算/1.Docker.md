#### 一、docker下载、安装及配置

##### 设置docker源地址

1. upstart的系统

   - 编辑 /etc/default/docker ，在 DOCKER_OPTS 中配置
   - 重启服务：sudo service docker restart

2. systemd的系统： /etc/docker/daemon.json 中写入如下内容（若没有文件则新建）

   ```json
   {   
     "registry-mirrors": [
       "https://xxxxxxxx.mirror.aliyuncs.com"
     ]
   }
   ```

   - 重新启动服务

     ```bash
     sudo systemctl daemon-reload
     sudo systemctl restart docker
     ```

**注**：1.需保持该文件符合json规范，否则docker将不能启动；2.检查加速地址是否生效：docker info

##### docker安装

- mac
  1. 浏览器下载安装包（www.docker.com）
  2. 安装，点击运行，`docker info`检测是否运行
  3. 可以配置docker源地址
- linux
  1. sudo wget -qO- httpd://get.docker.com | sh # 将wget下载简化输出到标准输出，将命令传递给sh执行。
  2. sudo usermod -aG docker $USER # 将用户添加到docker用户组
  3. docker info
```bash
$ docker --version # 查看docker的版本
$ docker --help # docker帮助文档
```

#### 二、Dokcer镜像

##### 查找镜像

docker search httpd

##### 获取镜像

docker pull [选项] [Docker镜像地址[:端口号]/] 仓库名[:标签]

- 仓库名：`<用户名>/<软件名>`，对于 Docker Hub ，如果不给出用户名，则默认为 library ，也就是官方镜像

  ```bash
  docker pull ubuntu:16.04	# 获取官方标签为16.04的ubuntu镜像
  ```

##### 列出镜像

docker image ls

- 列表包含了 `仓库名` 、`标签` 、`镜像ID` 、`创建时间`、以及`所占用的空间`

**注**：Docker镜像是多层存储结构，并且可以继承、复用。因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。可使用`docker system df`命令查看镜像、容器、数据卷所占空间

**虚悬镜像**：新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 `<none>` 的镜像

```bash
docker image ls -f dangling=true	# 显示虚悬镜像
docker image prune	# 删除未使用的镜像
docker image ls -a	# 列出所有镜像
docker image ls [仓库名:标签名]	# 列出指定镜像
docker image -f since=mongo:3.2	# -f选项表示过滤，列出mongo:3.2以后的版本。since:往后，before:之前
docker image ls -q	# 以特定格式列出镜像，仅列出镜像ID
docker inspect 镜像ID	# 列出镜像详细信息
```

##### 删除本地镜像

docker image rm [选项] <镜像1> [<镜像2> ...]

#### 三、Docker容器

##### 使用镜像，生成容器

docker run [options] image [command] [arg...] 

- -i:交互式操作
- -t：终端
- -d：后台运行容器并返回容器ID
- -p：指定宿主机端口映射到容器服务端口
- --name：指定容器的名称
- --rm：如果容器为exit状态，会自动删除创建的容器
- --net:指定要加入的网络
-  -v:将本地文件和容器文件进行映射

```bash
docker run -it imageName/ImageID /bin/bash	# 指定镜像生成容器，并指定bash终端进入容器交互
docker run -p 8080:80 imageName	# 生成容器，指定容器端口80映射到宿主机8080端口
docker run -itd --name mmtest imageName/ImageID	/bin/bash	# 后台运行生成容器并指定容器名称为mmtest
```

##### 列出容器

```bash
docker container ls # 查看运行的容器，精简命令：docker ps
docker ps -a	# 查看所有容器
docker history 容器ID # 查看容器运行的历史记录
docker inspect 容器ID	# 查看容器的配置和状态信息
```

##### 停止/重启容器

```bash
docker stop 容器ID	# 停止容器
docker restart 容器ID	# 开启容器
docker pause 容器ID	# 暂停容器状态
docker unpause 容器ID	# 将暂停的容器启动
```

##### 进入已启动的容器

```bash
docker exec -it 容器ID /bin/bash
```

##### 删除容器

```bash
docker rm -f 容器ID
```

##### 容器其他操作

```bash
docker cp xx.html ContainID://user/share/nginx/xx.html	# 拷贝本机xx.html到容器下
docker top ContainID # 查看容器的进程信息
docker stats ContainID # 查看容器的资源信息
docker logs ContainID	# 查看容器内部标准输出
```

**注**：当搭建容器运行状态异常时，通过`docker logs ContainID`查看日志

#### 四、创建镜像

1. 从已经创建的容器中更新镜像，并且提交这个镜像

   - -m：提交信息
   - -a：镜像作者

   ```bash
   docker commit -m="msg" -a="msg" ContainID ImageName:tag # 保存改动为新的image
   ```

2. 使用 Dockerfile 指令来创建一个新的镜像

   - 新建Dockerfile文件

     ```dockerfile
     
     ```

     




##### 3.共享images

- 上传image到Docker Respository

  ```bash
  # 1.登录
  docker login
  # 2.推送
  docker build -t mycontainer:latest .
  docker push mycontainer:latest
  ```

- 导出为压缩文件，在导入

  ```bash
  # 导出为压缩文件
  docker save -o mycontainer.tar mycontainer:latest
  # 导入压缩文件
  docker load -i mycontainer.tar
  ```

#### 五、dockerfile

- Dockerfile是一个文本文件，用来配置image。Docker根据Dockerfile生成二进制的image文件

##### 1.第一个Dockerfile

  ```dockerfile
  FROM alpine:latest
  MAINTAINER zsm
  CMD echo 'hello docker'
  ```
  FROM alpine:latest 表示要生成一个镜像，需要的一个base基础镜像，alpine是针对于linux生成的一个极小的文件
  MAINTAINER zsm  提示信息
  CMD echo 'hello docker' 表示运行的命令

##### 2.创建自定义image

1. 创建一个fun.py文件生成字符串团

   ```python
   from cowpy import cow
   
   print(cow.milk_random_cow("Hello world"))
   ```

2. 创建一个requirements.txt指定库的信息

   > cowpy==1.1.0

3. 项目根目录下编写Dockerfile文件，touch Dockerfile

   ```dockerfile
   # 指定基础镜像，FROM 基础镜像:标签版本标号
   FROM python:alpine
   LABEL maintaier="zsm <zsm@qq.com>" # 镜像的元数据信息，仅做描述。可以写多个LABEL
   LABEL description="define Dockerfile Demo"
   # ADD可以将远程资源下载后复制到容器，也可以将本地压缩文件解压后复制到容器中
   # COPY将requirements.txt、fun.py拷贝到image文件/app目录
   COPY . /app 
   # 指定接下来的工作路径为/app
   WORKDIR /app 
   # RUN用于容器中执行linux命令，如果有多条命令，优化选择使用一个RUN去执行多条命令，取代多个RUN执行单个命令
   RUN pip install -r requirements.txt
   # ENV key=value 指定环境变量
   # VoLUME指定容器哪个目录或文件可以映射
   VoLUME /app/
   # EXPOSE指定容器可以暴露的端口
   EXPOSE 8000
   # USER root:设置运行其他命令的用户
   # CMD指定容器运行（docker run）时默认执行的命令
   #	有两种格式：1.shell格式；2.exec格式（常用）
   #		exec格式：["命令的绝对路径", "参数1", "参数2"]
   #		shell格式：命令的绝对路径 参数1 参数2
   CMD ["python", "fun.py"]
   ```

   ps：新建文本文件.dockerignore，在文件里填写需要忽略的文件

4. 构建image文件

   ```bash
   # -t：指定镜像的名字,v1表示版本标签，.表示Dockerfile所在路径，docker build -t 镜像名:tag -f dockerfile文件路径
   $ docker build -t MyImage:v1 .
   ```
   
   备：可以在Dockerfile文件FROM之上定义ARG，在构建镜像中指定参数
   
   ```dockerfile
   ARG CODE_VERSION=alpine
   FROM python:${CODE_VERSION}
   ```
   
   ```bash
   $ docker build --build-arg CODE_VERSION=3.7-alpine -t 镜像名:tag
   ```

##### 2.ENTRYPOINT vs CMD

- 不同点

  **cmd**：

  1. 运行容器时，不加任何参数，会自动执行CMD，如果添加了参数则会忽略CMD

     ```dockerfile
     FROM alpine
     CMD ["ls", "/"]
     
     # docker build -t TestImage
     # docker run --name TestContainer --rm TestImage /bin/sh -c ps
     ```

  2. 如果有多个CMD，则只会最后一个执行，其他都会被忽略

  **ENTRYPOINT**：

  1. 运行容器时，ENTRYPOINT执行的命令不会被覆盖
  2. 如果有多个ENTRYPOINT命令，只有最后一个被执行

- 共同点

  1. ==CMD常放在ENTRYPOINT后面作为ENTRYPOINT的默认参数==

     ```dockerfile
     # 相当于执行cat fun.py /etc/passwd
     ENTRYPOINT ["cat", "fun.py"]
     CMD ["/etc/passwd"]
     ```

#### 六、network

##### 1.docker0

- 默认容器与宿主机之间沟通的桥梁

##### 2.网络类型

- briage：==自定义briage模型，可以通过容器名互反==
  - nat网络模型
  - 虚拟交换机
- host
  - 与宿主机共享网络，--net=host
- none
  - 不配置网络，--net=none
- overlay
  - 不同网络进行通信，--net=container:ContainerName

##### 3.网络基本操作

```bash
$ docker network ls	# 查看当前网络
$ docker network inspect NetworkName # 查看网络详情
$ docker network create mynetwork # 创建一个mynetwork的网络，默认为桥接模式
# 选项：
#	-d：指定网络类型，如：-d briage
#	--subnet:指定子网，如：--subnet 172.16.88.0/24
$ docker network -d briage --subnet 172.16.88.0/24 mynetworktest
$ docker run --name nginx -d -P --net mynetworktest nignx:alpine	# 创建名为nginx的容器并加入mynetworktest网络
```

#### 七、volume

##### 1.介绍

- 使用数据卷实现数据持久化
- 数据备份/数据共享

##### 2.相关操作

```bash
# 创建
$ docker volume create [OPTIONS] [VOLUME] 
# 查看
$ docker volume inspect [OPTIONS] VOLUME [VOLUME...] 
# 挂载
$ docker run -v 宿主机目录:容器目录
# 删除
$ docker volume rm [OPTIONS] VOLUME [VOLUME...] 

# 启动一个容器命名为nginx，随机分配端口，并将当前目录和容器/user/share/nginx/html作映射（双向同步）
$ docker run --name nginx -d -v $PWD:/user/share/nginx/html -P nginx:alpine
# 在映射文件后面加ro，表示宿主机只有读的权限
$ docker run --name nginx -d -v $PWD:/user/share/nginx/html:ro -P nginx:alpine
# 实际中，常用数据卷和容器文件进行映射,如果宿主机有myvolume数据卷直接进行映射，若是没有，创建myvolume并映射
$ docker run --name nginx -d -v myvolume:/user/share/nginx/html:ro -P nginx:alpine
```



#### 八、docker compose

作用：同时启动多个容器

##### 1.安装

##### 2.使用docker compose

- 项目根目录下创建docker-compose.yaml

  ```shell
  # 指定版本信息
  VERSION: '3'
  
  # 定义服务
  services:
  	# 创建的具体服务
  	db:
  		# 指定镜像名（镜像名:tag），如果本地没有，会从docker hub中下载
  		image:mariadb
		# 运行容器时，指定需要执行的命令或参数
  		command:--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
  		# 指定数据持久化映射
  		volumes:
  			# 数据卷名称或宿主机文件
  			mysql_db:/var/bin/mysql
  		# 指定容器失败时（EXITED），重启策略
  		restart:always
  		# 指定容器中的全局变量
          environment:
          	MYSQL_ROOT_PASSWORD:"123456"
          	MYSQL_DATABASE:my_django
          # 指定容器加入的网络
          networks:
          	django_app_net
      
      django_app:
      	# 指定django_app依赖的服务
      	depends_on:
      		db
      	# 指定通过Dockerfile路径（./django_app_docker）去构建（django_app:v1）镜像
      	build:./django_app_docker
      	image:django_app:v1
      	restart:always
          volumes:
          	logs:/usr/src/app/logs/
          	django_code:/usr/src/app/
          networks:
          	django_app_net
          	
  # 指定网络
  networks:
  	# 指定网络名称，默认会创建briage桥接网络
  	django_app_net
  	
  # 指定数据卷
  volumes:
  	mysql_db:
      django_code:    	
  	logs:		
  ```
  
  ##### 3.常用命令
  
  ```bash
  # 查看docker-compose.yaml文件配置是否有误
  $ docker-compose config
  # 如果执行命令目录下compose文件未命名docker-compose，需要使用-f指定文件
  $ docker-compose -f docker-pose.yaml config
  # 通过docker-compose文件启动容器，会在卷、网络、容器前面加前缀（当前所在目录名），可以使用-p指定前缀。一旦指定了，在删除容器的时候也需要使用-p指定相应前缀删除
  docker-compose -p my_project up	# 运行容器
  docker-compose -p my_project down # 删除容器、网络...
  ```

#### 九、Docker Swarm

##### 1.Swarm manager

- 切换、加入、移除、维护节点

##### 2.Swarm work

- 运行任务的节点
- 托管容器任务

##### 3.创建集群

- 初始化

##### 4.常用命令

```bash
# docker swarm去操作集群
$ docker swarm --help 
# docker node去操作节点
$ docker node --help
# docker service去操作服务
$ docker service --help
$ docker service ls
```
