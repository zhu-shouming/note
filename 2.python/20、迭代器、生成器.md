### 一、可迭代对象

> - 可以被for迭代的对象都是可迭代对象
>
> - 对象有`__iter__()`方法，都是可迭代对象。`__iter__()`要求返回的对象具有`__next__()`方法
>
> - 常见的可迭代对象：list、tuple、str

```python
# 可迭代对象（耗内存）--python2 range()的实现方式
from typing import Iterable, Iterator

def range_test(stop):
    start = 0
    result = []
    while start < stop:
        result.append(start)
        start += 1
    return result
if __name__ == '__main__':
    f = range_test(10)
	print(isinstance(f, Iterable))	# True，检验是否是可迭代类型
    print(isinstance(f, Iterator))	# False，检验是否是可迭代器
```

```python
# 可迭代对象（省内存）--python2 xrange()的实现方式
class Next(object):
    def __init__(self, stop, start=-1):
        self.start = start
        self.stop = stop
    def __next__(self):
        if self.start >= self.stop - 1:
            raise StopIteration
        self.start += 1
        return self.start
    
class MyRange(object):
    def __init__(self, stop):
        self.stop = stop
    def __iter__(self):
        return Next(self.stop)    
if __name__ == '__main__':
    for i in MyRange(10):	# 等价于下面while手动执行
        print(i)
    test = MyRange(10).__iter__()	# while手动执行
    flag = 0
    while flag < 10:
        print(test.__next__())
        flag += 1 
    print(isinstance(MyRange(10), Iterable))	# True
    print(isinstance(MyRange(10), Iterator))	# False 
    print(isinstance(Next(10), Iterable))	# False
    print(hasattr(list, '__iter__'))	# True，检验list中是否有__iter__
```

### 二、迭代器

> - 是特殊的可迭代对象
> - 迭代器必须具有`__iter__()`和`__next__()`方法
> - 核心：通过``__next__``方法记住迭代的位置，迭代完成抛出StopIteration异常

```python
# 定义一个迭代器
class MyIter(object):
    def __init__(self, stop, start=-1):
        self.start = start
        self.stop = stop
    def __iter__(self):
        return self
    def __next__(self):
        if self.start >= self.stop - 1:
            raise StopIteration
        self.start += 1
        return self.start
if __name__ == '__main__':
    print(isinstance(MyIter(), Iterator))	# True,判断是否是迭代器 
```

### 三、生成器

> - 通过__yield__关键字创建生成器对象
> - 调用**next()**方法访问生成器的下一个元素
>
> - **yield**暂时跳出函数，会记住函数执行的状态，下一次执行还会从跳出的地方继续执行；
>
> - __return__的区别：return跳出函数，返回结果。

```python
# 迭代器手工实现比较复杂，python提供了生成器对象，生成器对象的目的就是获得迭代器对象
import sys
 
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
while True:
    try:
        print (next(f), end=" ")
    except StopIteration:
        sys.exit()
```

