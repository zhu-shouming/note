##### 使用`__new__`实现单例模式

```python
class MyClass(object):
    obj = None
    def __new__(cls, *args, **kwargs):
        """如果对象已创建，就直接返回创建的对象，如果未创建，创建对象并返回"""
        if cls.obj is None:
            cls.obj = super().__new__(cls)
        reutrn cls.obj
```

##### 使用装饰器实现单例模式：降低代码冗余性，优化代码

```python
def singleton(cls):
	instance = {}	# 字典接收对象的实例
	def wrapper(*args, **kwargs):
		if not instance:	# 如果字典为空，创建一个实例
			instance[cls] = cls(*args, **kwargs):
        return instance[cls]
    return wrapper
@singleton
class Myclass(obj):
    pass
```

##### 使用import实现单例模式

> 第一次导入模块时，解释器会创建pyc文件，以后再导入的时候，直接使用的是pyc文件
>
> pyc文件是在import导入包生成，部署项目的时候需要清除pyc文件

##### 用指定的类方法实现单例模式

```python
class MyClass(object):
    __instance = None
    def __init__(self, *args, **kwargs):
        pass
    @classmethod
    def get_singleton_obj(cls. *arg, **kwargs):
        if not cls.__instance:
            cls.__instance = cls(*args, **kwargs)
        return cls.__instance
if __name__ = '__main__':
    MyClass.get_singleton_obj()
```
